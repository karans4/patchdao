#!/usr/bin/env python3
"""fix — AI-powered command fixer. The core loop of PatchDAO.

Usage:
    fix <command>           Run command; if it fails, find/generate a fix
    fix --safe <command>    Sandboxed mode: overlay snapshot + rollback on failure
    fix --cache             Show cached fixes
    fix --stats             Show spending stats
    fix --clear             Clear the fix cache
    fix --budget <cents>    Set max spend per session (default: 50 cents)
"""

import subprocess
import hashlib
import sqlite3
import sys
import os
import json
import time
import platform
import shutil

# --- Config ---
DB_DIR = os.path.expanduser("~/.patchdao")
DB_PATH = os.path.join(DB_DIR, "fixes.db")
MAX_RETRIES = 3
DEFAULT_BUDGET_CENTS = 50  # half a dollar

# Claude API
API_URL = "https://api.anthropic.com/v1/messages"
MODEL = "claude-haiku-4-5-20251001"  # cheap and fast

# Rough cost estimate: ~$0.25/MTok input, $1.25/MTok output for haiku
# Average fix query ~2k tokens in, ~500 tokens out ≈ $0.001 per call
COST_PER_CALL_CENTS = 0.1  # conservative estimate


def get_api_key():
    key = os.environ.get("ANTHROPIC_API_KEY", "")
    if not key:
        keyfile = os.path.expanduser("~/.patchdao/api_key")
        if os.path.exists(keyfile):
            with open(keyfile) as f:
                key = f.read().strip()
    return key


# --- Database ---

def init_db():
    os.makedirs(DB_DIR, exist_ok=True)
    conn = sqlite3.connect(DB_PATH)
    conn.execute("""
        CREATE TABLE IF NOT EXISTS fixes (
            error_hash TEXT,
            env_hash TEXT,
            fix_script TEXT,
            success_count INTEGER DEFAULT 0,
            fail_count INTEGER DEFAULT 0,
            created_at REAL,
            PRIMARY KEY (error_hash, env_hash)
        )
    """)
    conn.execute("""
        CREATE TABLE IF NOT EXISTS stats (
            key TEXT PRIMARY KEY,
            value REAL
        )
    """)
    # init spend tracker
    conn.execute("INSERT OR IGNORE INTO stats VALUES ('total_spend_cents', 0)")
    conn.execute("INSERT OR IGNORE INTO stats VALUES ('session_spend_cents', 0)")
    conn.execute("INSERT OR IGNORE INTO stats VALUES ('fixes_served', 0)")
    conn.execute("INSERT OR IGNORE INTO stats VALUES ('fixes_generated', 0)")
    conn.commit()
    return conn


def get_stat(conn, key):
    row = conn.execute("SELECT value FROM stats WHERE key=?", (key,)).fetchone()
    return row[0] if row else 0


def inc_stat(conn, key, amount=1):
    conn.execute("UPDATE stats SET value = value + ? WHERE key=?", (amount, key))
    conn.commit()


def lookup_fix(conn, error_hash, env_hash):
    """Check cache. Try exact env match first, then any env."""
    row = conn.execute(
        "SELECT fix_script FROM fixes WHERE error_hash=? AND env_hash=? AND success_count > fail_count",
        (error_hash, env_hash)
    ).fetchone()
    if row:
        return row[0], True  # exact match

    row = conn.execute(
        "SELECT fix_script, env_hash FROM fixes WHERE error_hash=? AND success_count > fail_count ORDER BY success_count DESC LIMIT 1",
        (error_hash,)
    ).fetchone()
    if row:
        return row[0], False  # fuzzy match

    return None, False


def store_fix(conn, error_hash, env_hash, fix_script):
    conn.execute(
        "INSERT OR REPLACE INTO fixes (error_hash, env_hash, fix_script, success_count, fail_count, created_at) VALUES (?, ?, ?, 1, 0, ?)",
        (error_hash, env_hash, fix_script, time.time())
    )
    conn.commit()


def record_outcome(conn, error_hash, env_hash, success):
    col = "success_count" if success else "fail_count"
    conn.execute(
        f"UPDATE fixes SET {col} = {col} + 1 WHERE error_hash=? AND env_hash=?",
        (error_hash, env_hash)
    )
    conn.commit()


# --- Environment Fingerprinting ---

def get_env_fingerprint():
    """Capture system state for context-aware fix matching."""
    info = {
        "os": platform.system(),
        "release": platform.release(),
        "machine": platform.machine(),
        "distro": "",
        "shell": os.environ.get("SHELL", ""),
        "python": platform.python_version(),
    }

    # Linux distro
    try:
        with open("/etc/os-release") as f:
            for line in f:
                if line.startswith("PRETTY_NAME="):
                    info["distro"] = line.split("=", 1)[1].strip().strip('"')
                    break
    except FileNotFoundError:
        pass

    # Package managers available
    pms = []
    for pm in ["apt", "dnf", "pacman", "brew", "pip", "npm", "cargo"]:
        if shutil.which(pm):
            pms.append(pm)
    info["package_managers"] = pms

    return info


def env_hash(fingerprint):
    """Deterministic hash of environment."""
    canonical = json.dumps(fingerprint, sort_keys=True)
    return hashlib.sha256(canonical.encode()).hexdigest()[:16]


def error_hash(stderr_text):
    """Hash the meaningful part of an error message."""
    lines = stderr_text.strip().splitlines()
    # Take last 5 lines (usually the actual error, not warnings)
    significant = "\n".join(lines[-5:]) if len(lines) > 5 else stderr_text.strip()
    return hashlib.sha256(significant.encode()).hexdigest()[:16]


# --- LLM Agent ---

OLLAMA_URL = "http://localhost:11434/api/generate"
OLLAMA_MODEL = "qwen2.5-coder:1.5b"


def call_claude(prompt, api_key):
    """Call Claude API via httpx. Returns the text response."""
    import httpx

    resp = httpx.post(
        API_URL,
        headers={
            "x-api-key": api_key,
            "anthropic-version": "2023-06-01",
            "content-type": "application/json",
        },
        json={
            "model": MODEL,
            "max_tokens": 1024,
            "messages": [{"role": "user", "content": prompt}],
        },
        timeout=30,
    )

    if resp.status_code != 200:
        raise RuntimeError(f"Claude API error {resp.status_code}: {resp.text[:200]}")

    data = resp.json()
    return data["content"][0]["text"]


def call_ollama(prompt):
    """Call local Ollama instance. Returns the text response."""
    import httpx

    resp = httpx.post(
        OLLAMA_URL,
        json={
            "model": OLLAMA_MODEL,
            "prompt": prompt,
            "stream": False,
        },
        timeout=60,
    )

    if resp.status_code != 200:
        raise RuntimeError(f"Ollama error {resp.status_code}: {resp.text[:200]}")

    return resp.json()["response"]


def ollama_available():
    """Check if Ollama is running."""
    try:
        import httpx
        resp = httpx.get("http://localhost:11434/api/tags", timeout=2)
        return resp.status_code == 200
    except Exception:
        return False


def build_prompt(command, stderr_text, env_info):
    """Build the fix prompt (shared between backends)."""
    return f"""You are a DevOps agent. A command failed. Generate a fix.

FAILED COMMAND: {command}

ERROR OUTPUT:
{stderr_text[-2000:]}

SYSTEM INFO:
- OS: {env_info.get('distro', '')} ({env_info['os']} {env_info['release']})
- Arch: {env_info['machine']}
- Shell: {env_info['shell']}
- Python: {env_info['python']}
- Package managers: {', '.join(env_info.get('package_managers', []))}

Respond with ONLY a JSON object, no markdown, no explanation:
{{"fix": "the shell command(s) to run", "explanation": "one line why", "retry": true}}

The "fix" field should contain shell commands that fix the underlying issue.
Set "retry" to true if the original command should be re-run after the fix.
Keep it minimal. Prefer the system package manager.
Use sudo for apt/dnf/pacman commands (they require root).
Use pip install --break-system-packages if apt doesn't have the package.
Combine commands with && for atomicity."""


def parse_llm_response(raw):
    """Parse JSON from LLM response (handles markdown fences)."""
    text = raw.strip()
    if text.startswith("```"):
        text = "\n".join(text.split("\n")[1:])
        if text.endswith("```"):
            text = text[:-3]
        text = text.strip()
    # Try to extract JSON if there's surrounding text
    if not text.startswith("{"):
        start = text.find("{")
        end = text.rfind("}") + 1
        if start >= 0 and end > start:
            text = text[start:end]
    return json.loads(text)


def generate_fix(command, stderr_text, env_info, api_key):
    """Ask an LLM to generate a fix. Tries Claude first, falls back to Ollama."""
    prompt = build_prompt(command, stderr_text, env_info)

    # Choose backend: Claude API > Ollama
    backend = None
    if api_key:
        backend = "claude"
    elif ollama_available():
        backend = "ollama"
    else:
        raise RuntimeError("No LLM backend available (no API key, Ollama not running)")

    if backend == "claude":
        raw = call_claude(prompt, api_key)
    else:
        raw = call_ollama(prompt)

    return parse_llm_response(raw), backend


# --- Sandbox (Transactional Execution) ---

# Allowlist: patterns of files a fix is permitted to touch.
# Anything outside these paths triggers a security warning.
ALLOWED_PATHS = {
    "python-pkg": [
        "/usr/lib/python*",
        "/usr/local/lib/python*",
        "/usr/share/python*",
        "/var/lib/dpkg",
        "/var/cache/apt",
        "/var/lib/apt",
        "/etc/apt",
    ],
    "system-pkg": [
        "/usr/bin/*",
        "/usr/lib/*",
        "/usr/share/*",
        "/var/lib/dpkg*",
        "/var/cache/apt*",
        "/var/cache/debconf*",
        "/var/lib/apt*",
        "/var/log/dpkg*",
        "/var/log/apt*",
        "/var/lib/update-notifier*",
        "/etc/apt*",
        "/etc/ld.so.*",
    ],
    "compiler": [
        "/usr/include/*",
        "/usr/lib/gcc/*",
        "/usr/bin/gcc*",
        "/usr/bin/cc*",
        "/tmp/*",
    ],
}

# Default: union of all profiles
DEFAULT_ALLOWED = []
for paths in ALLOWED_PATHS.values():
    DEFAULT_ALLOWED.extend(paths)


class Sandbox:
    """OverlayFS sandbox for transactional fix execution.

    Security layers:
    1. OVERLAY:   Filesystem snapshot — changes are isolated until commit
    2. NETNS:     Network isolation — fix cannot phone home
    3. DIFF:      Full audit of every file changed — shown before commit
    4. ALLOWLIST: Only expected paths may be modified — unexpected = blocked

    The "proof" is: does the original command succeed after the fix?
    Both parties (user and agent) agree on this before execution.
    """

    def __init__(self, allowed_paths=None):
        self.workdir = None
        self.overlay_dirs = []  # (target, upper, work, merged)
        self.allowed_paths = allowed_paths or DEFAULT_ALLOWED

    def _sudo(self, cmd):
        """Run a command with sudo."""
        password = os.environ.get("SUDO_PASSWORD", "")
        if password:
            return subprocess.run(
                f"echo '{password}' | sudo -S {cmd}", shell=True,
                capture_output=True, text=True
            )
        return subprocess.run(
            f"sudo {cmd}", shell=True,
            capture_output=True, text=True
        )

    def setup(self):
        """Create overlay workspace."""
        import tempfile
        self.workdir = tempfile.mkdtemp(prefix="fix-sandbox-")

        # Overlay the directories that package managers modify
        # Include /home for completeness (catch rogue dotfile writes)
        targets = ["/usr", "/var", "/etc", "/home", "/tmp"]
        for target in targets:
            if not os.path.isdir(target):
                continue
            name = target.strip("/").replace("/", "_")
            upper = os.path.join(self.workdir, f"{name}_upper")
            work = os.path.join(self.workdir, f"{name}_work")
            merged = os.path.join(self.workdir, f"{name}_merged")
            os.makedirs(upper)
            os.makedirs(work)
            os.makedirs(merged)
            self.overlay_dirs.append((target, upper, work, merged))

        # Mount overlays
        for target, upper, work, merged in self.overlay_dirs:
            r = self._sudo(
                f"mount -t overlay overlay "
                f"-o lowerdir={target},upperdir={upper},workdir={work} {merged}"
            )
            if r.returncode != 0:
                raise RuntimeError(f"Failed to mount overlay for {target}: {r.stderr}")

    def run_in_sandbox(self, command, network=False):
        """Execute a command in an isolated namespace.

        - Mount namespace: overlays bind-mounted over real dirs
        - Network namespace (if network=False): no outbound access
        """
        bind_cmds = []
        for target, upper, work, merged in self.overlay_dirs:
            bind_cmds.append(f"mount --bind {merged} {target}")

        safe_cmd = command.replace("'", "'\\''")
        script = " && ".join(bind_cmds + [safe_cmd])

        # unshare --mount isolates bind mounts
        # unshare --net isolates network (no curl/wget/exfiltration)
        ns_flags = "--mount"
        if not network:
            ns_flags += " --net"

        full_cmd = f"unshare {ns_flags} -- bash -c '{script}'"

        password = os.environ.get("SUDO_PASSWORD", "")
        if password:
            full_cmd = f"echo '{password}' | sudo -S {full_cmd}"
        else:
            full_cmd = f"sudo {full_cmd}"

        return subprocess.run(
            full_cmd, shell=True,
            capture_output=True, text=True,
            timeout=120
        )

    def get_diff(self):
        """Return list of all files changed in the overlay.

        This is the complete audit trail — the overlay upper dir
        contains ONLY the diff from the original filesystem.
        """
        import fnmatch
        changed = []
        for target, upper, work, merged in self.overlay_dirs:
            for root, dirs, files in os.walk(upper):
                for f in files:
                    overlay_path = os.path.join(root, f)
                    # Translate back to real path
                    rel = os.path.relpath(overlay_path, upper)
                    real_path = os.path.join(target, rel)

                    # Stat for size
                    try:
                        size = os.path.getsize(overlay_path)
                    except OSError:
                        size = 0

                    # Check if this is a whiteout (deletion marker)
                    is_delete = f.startswith(".wh.")

                    changed.append({
                        "path": real_path,
                        "overlay_path": overlay_path,
                        "size": size,
                        "is_delete": is_delete,
                    })
        return changed

    def check_allowlist(self, changed_files):
        """Check if all changed files match the allowlist.

        Returns (allowed: list, violations: list)
        """
        import fnmatch
        allowed = []
        violations = []

        for entry in changed_files:
            path = entry["path"]
            is_ok = False
            for pattern in self.allowed_paths:
                # Match the pattern against the path and all parent dirs
                if fnmatch.fnmatch(path, pattern):
                    is_ok = True
                    break
                # Also check if the path starts with a dir pattern
                # e.g. /var/lib/dpkg* should match /var/lib/dpkg/status
                base_pattern = pattern.rstrip("*")
                if path.startswith(base_pattern):
                    is_ok = True
                    break
            if is_ok:
                allowed.append(entry)
            else:
                violations.append(entry)

        return allowed, violations

    def commit(self):
        """Merge overlay changes into the real filesystem."""
        for target, upper, work, merged in self.overlay_dirs:
            if os.listdir(upper):
                r = self._sudo(f"rsync -a {upper}/ {target}/")
                if r.returncode != 0:
                    raise RuntimeError(f"Failed to merge {upper} -> {target}: {r.stderr}")

    def rollback(self):
        """Discard all changes."""
        pass  # cleanup() handles it

    def cleanup(self):
        """Unmount overlays and delete workspace."""
        if not self.workdir:
            return
        for target, upper, work, merged in self.overlay_dirs:
            self._sudo(f"umount {merged} 2>/dev/null")
        self._sudo(f"rm -rf {self.workdir}")
        self.workdir = None


def format_size(n):
    """Human-readable file size."""
    for unit in ("B", "KB", "MB", "GB"):
        if n < 1024:
            return f"{n:.0f}{unit}"
        n /= 1024
    return f"{n:.1f}TB"


def run_sandboxed_fix(fix_cmd, verify_cmd, status_fn):
    """Execute a fix transactionally with full security:

    1. Snapshot filesystem (overlayfs)
    2. Run fix in sandbox (no network, isolated mounts)
    3. AUDIT: show every file changed
    4. ALLOWLIST: flag unexpected modifications
    5. Run verification in sandbox
    6. If clean + verified → commit
    7. Otherwise → rollback, system untouched

    Returns (success: bool, fix_output: str, verify_output: str)
    """
    sandbox = Sandbox()
    try:
        status_fn(f"{C_BLUE}#{C_RESET}", "Creating filesystem snapshot...")
        sandbox.setup()

        # --- MITIGATION 2: Network isolation ---
        # Fixes that need network (apt, pip, npm, cargo) get it.
        # Everything else runs air-gapped.
        needs_net = any(pkg_cmd in fix_cmd for pkg_cmd in
                        ["apt ", "pip ", "npm ", "cargo ", "dnf ", "pacman ",
                         "wget ", "curl ", "git clone"])
        if needs_net:
            status_fn(f"{C_YELLOW}*{C_RESET}",
                       f"[sandbox] Running fix (network: package install): {fix_cmd[:50]}")
        else:
            status_fn(f"{C_YELLOW}*{C_RESET}",
                       f"[sandbox] Running fix (network disabled): {fix_cmd[:50]}")
        fix_result = sandbox.run_in_sandbox(fix_cmd, network=needs_net)
        if fix_result.returncode != 0:
            status_fn(f"{C_RED}!{C_RESET}", f"[sandbox] Fix failed: {fix_result.stderr[:100]}")
            sandbox.rollback()
            return False, fix_result.stderr, ""

        # --- MITIGATION 1: Diff audit ---
        changed = sandbox.get_diff()
        if changed:
            status_fn(f"{C_BLUE}#{C_RESET}",
                       f"Diff audit: {len(changed)} file(s) modified")
            for entry in changed[:20]:  # cap display at 20
                icon = "-" if entry["is_delete"] else "+"
                sz = format_size(entry["size"])
                status_fn(f"{C_DIM} {C_RESET}",
                           f"  {icon} {entry['path']} ({sz})")
            if len(changed) > 20:
                status_fn(f"{C_DIM} {C_RESET}",
                           f"  ... and {len(changed) - 20} more")
        else:
            status_fn(f"{C_DIM} {C_RESET}", "No files modified.")

        # --- MITIGATION 3: Allowlist check ---
        allowed, violations = sandbox.check_allowlist(changed)
        if violations:
            status_fn(f"{C_RED}!{C_RESET}",
                       f"SECURITY: {len(violations)} file(s) outside allowlist!")
            for v in violations[:10]:
                status_fn(f"{C_RED}!{C_RESET}",
                           f"  BLOCKED: {v['path']}")

            # In safe mode, violations = hard stop
            status_fn(f"{C_RED}!{C_RESET}",
                       "Fix modified unexpected files. Rejecting. System unchanged.")
            sandbox.rollback()
            return False, fix_result.stdout, "ALLOWLIST_VIOLATION"
        elif changed:
            status_fn(f"{C_GREEN}+{C_RESET}",
                       f"All {len(allowed)} modified file(s) within allowlist.")

        # --- Verification (network allowed for verification) ---
        status_fn(f"{C_BLUE}>{C_RESET}", f"[sandbox] Verifying: {verify_cmd[:60]}")
        verify_result = sandbox.run_in_sandbox(verify_cmd, network=True)

        if verify_result.returncode == 0:
            status_fn(f"{C_GREEN}+{C_RESET}", "Verification passed. Committing changes...")
            sandbox.commit()
            return True, fix_result.stdout, verify_result.stdout
        else:
            status_fn(f"{C_RED}!{C_RESET}",
                       "Verification failed. Rolling back (system unchanged).")
            sandbox.rollback()
            return False, fix_result.stdout, verify_result.stderr

    except Exception as e:
        status_fn(f"{C_RED}!{C_RESET}", f"Sandbox error: {e}")
        sandbox.rollback()
        return False, "", str(e)
    finally:
        sandbox.cleanup()


# --- UI ---

C_RESET = "\033[0m"
C_RED = "\033[31m"
C_GREEN = "\033[32m"
C_YELLOW = "\033[33m"
C_BLUE = "\033[34m"
C_DIM = "\033[2m"
C_BOLD = "\033[1m"

# Disable color if not a terminal
if not sys.stderr.isatty():
    C_RESET = C_RED = C_GREEN = C_YELLOW = C_BLUE = C_DIM = C_BOLD = ""


def status(icon, msg):
    print(f"  {icon}  {msg}", file=sys.stderr)


def show_cache(conn):
    rows = conn.execute(
        "SELECT error_hash, env_hash, fix_script, success_count, fail_count, created_at FROM fixes ORDER BY created_at DESC"
    ).fetchall()
    if not rows:
        print("Cache is empty.")
        return
    print(f"\n{'HASH':<18} {'ENV':<18} {'OK':>4} {'FAIL':>4}  FIX")
    print("-" * 80)
    for r in rows:
        fix_preview = r[2][:40].replace("\n", " ")
        print(f"{r[0]:<18} {r[1]:<18} {r[3]:>4} {r[4]:>4}  {fix_preview}")
    print()


def show_stats(conn):
    print(f"\n  Total spend:     ${get_stat(conn, 'total_spend_cents') / 100:.4f}")
    print(f"  Fixes generated: {int(get_stat(conn, 'fixes_generated'))}")
    print(f"  Fixes served:    {int(get_stat(conn, 'fixes_served'))}")
    print()


# --- Main Loop ---

def run_fix(args):
    conn = init_db()
    command = " ".join(args)

    # Budget check
    budget = float(os.environ.get("FIX_BUDGET_CENTS", DEFAULT_BUDGET_CENTS))
    session_spend = get_stat(conn, "session_spend_cents")

    # Run the command
    status(f"{C_BLUE}>{C_RESET}", f"{C_BOLD}{command}{C_RESET}")
    proc = subprocess.run(command, shell=True, capture_output=True, text=True)

    if proc.stdout:
        sys.stdout.write(proc.stdout)
    if proc.returncode == 0:
        if proc.stderr:
            sys.stderr.write(proc.stderr)
        return 0

    # Command failed
    sys.stderr.write(proc.stderr)
    status(f"{C_RED}!{C_RESET}", f"Exited {proc.returncode}")

    if not proc.stderr.strip():
        status(f"{C_DIM}?{C_RESET}", "No stderr to analyze.")
        return proc.returncode

    # Fingerprint
    env_info = get_env_fingerprint()
    ehash = error_hash(proc.stderr)
    envhash = env_hash(env_info)

    status(f"{C_DIM}#{C_RESET}", f"error={ehash} env={envhash}")

    # Check cache
    cached_fix, exact = lookup_fix(conn, ehash, envhash)
    if cached_fix:
        match_type = "exact" if exact else "fuzzy"
        status(f"{C_GREEN}${C_RESET}", f"Cache hit ({match_type}): {C_DIM}{cached_fix[:60]}{C_RESET}")
        inc_stat(conn, "fixes_served")

        if os.environ.get("FIX_AUTO_YES"):
            pass
        elif sys.stdin.isatty():
            confirm = input(f"  ?  Apply cached fix? [Y/n] ")
            if confirm.strip().lower() == "n":
                return proc.returncode
        else:
            status(f"{C_DIM}i{C_RESET}", "Non-interactive mode, auto-applying.")

        status(f"{C_YELLOW}*{C_RESET}", "Applying fix...")
        fix_proc = subprocess.run(cached_fix, shell=True)
        if fix_proc.returncode != 0:
            status(f"{C_RED}!{C_RESET}", "Fix command failed.")
            record_outcome(conn, ehash, envhash, False)
            return fix_proc.returncode

        # Retry original
        status(f"{C_BLUE}>{C_RESET}", f"Retrying: {command}")
        retry = subprocess.run(command, shell=True)
        success = retry.returncode == 0
        record_outcome(conn, ehash, envhash, success)
        if success:
            status(f"{C_GREEN}+{C_RESET}", "Fixed.")
        else:
            status(f"{C_RED}!{C_RESET}", "Still failing after fix.")
        return retry.returncode

    # Cache miss — ask the LLM
    api_key = None if os.environ.get("FIX_FORCE_LOCAL") else get_api_key()
    use_ollama = ollama_available()

    if not api_key and not use_ollama:
        status(f"{C_RED}!{C_RESET}", "No fix in cache, no API key, and Ollama not running.")
        status(f"{C_DIM}i{C_RESET}", "Set ANTHROPIC_API_KEY or start Ollama (ollama serve)")
        return proc.returncode

    if api_key and session_spend + COST_PER_CALL_CENTS > budget:
        if use_ollama:
            api_key = None  # fall back to free local model
            status(f"{C_DIM}i{C_RESET}", "Budget exhausted, falling back to Ollama.")
        else:
            status(f"{C_RED}!{C_RESET}", f"Budget exhausted (${session_spend/100:.2f}/${budget/100:.2f})")
            return proc.returncode

    backend_name = "Claude" if api_key else "Ollama"
    status(f"{C_YELLOW}@{C_RESET}", f"Cache miss. Asking {backend_name}...")

    for attempt in range(MAX_RETRIES):
        try:
            result, backend_used = generate_fix(command, proc.stderr, env_info, api_key)
            break
        except json.JSONDecodeError:
            if attempt < MAX_RETRIES - 1:
                status(f"{C_DIM}~{C_RESET}", "Bad response, retrying...")
                continue
            status(f"{C_RED}!{C_RESET}", f"Could not parse fix from {backend_name}.")
            return proc.returncode
        except RuntimeError as e:
            status(f"{C_RED}!{C_RESET}", str(e))
            return proc.returncode

    if backend_used == "claude":
        inc_stat(conn, "session_spend_cents", COST_PER_CALL_CENTS)
        inc_stat(conn, "total_spend_cents", COST_PER_CALL_CENTS)
    inc_stat(conn, "fixes_generated")

    fix_cmd = result["fix"]
    explanation = result.get("explanation", "")
    should_retry = result.get("retry", True)

    status(f"{C_GREEN}${C_RESET}", f"Fix: {C_BOLD}{fix_cmd[:80]}{C_RESET}")
    if explanation:
        status(f"{C_DIM}i{C_RESET}", explanation)
    cost_str = f"~${COST_PER_CALL_CENTS/100:.4f}" if backend_used == "claude" else "free (local)"
    status(f"{C_DIM}~{C_RESET}", f"Cost: {cost_str} [{backend_used}]")

    if os.environ.get("FIX_AUTO_YES"):
        pass
    elif sys.stdin.isatty():
        confirm = input(f"  ?  Apply this fix? [Y/n] ")
        if confirm.strip().lower() == "n":
            return proc.returncode
    else:
        status(f"{C_DIM}i{C_RESET}", "Non-interactive mode, auto-applying.")

    # --- Execute fix (sandboxed or direct) ---
    safe_mode = os.environ.get("FIX_SAFE_MODE")

    if safe_mode:
        # Transactional execution: snapshot → fix → verify → commit/rollback
        status(f"{C_BLUE}#{C_RESET}", "Safe mode: fix runs in sandbox with rollback.")
        status(f"{C_DIM}i{C_RESET}", f"Contract: apply fix, then verify '{command}' succeeds.")

        success, fix_out, verify_out = run_sandboxed_fix(fix_cmd, command, status)

        if success:
            status(f"{C_GREEN}+{C_RESET}", "Contract satisfied. Changes committed.")
            store_fix(conn, ehash, envhash, fix_cmd)
            return 0
        else:
            status(f"{C_RED}!{C_RESET}", "Contract not satisfied. System unchanged.")
            return 1
    else:
        # Direct execution (original behavior)
        status(f"{C_YELLOW}*{C_RESET}", "Applying fix...")
        fix_proc = subprocess.run(fix_cmd, shell=True)

        if fix_proc.returncode != 0:
            status(f"{C_RED}!{C_RESET}", "Fix command failed.")
            return fix_proc.returncode

        if should_retry:
            status(f"{C_BLUE}>{C_RESET}", f"Retrying: {command}")
            retry = subprocess.run(command, shell=True)

            if retry.returncode == 0:
                status(f"{C_GREEN}+{C_RESET}", "Fixed! Caching solution.")
                store_fix(conn, ehash, envhash, fix_cmd)
                return 0
            else:
                status(f"{C_RED}!{C_RESET}", "Still failing. Fix not cached.")
                return retry.returncode
        else:
            status(f"{C_GREEN}+{C_RESET}", "Fix applied. Caching solution.")
            store_fix(conn, ehash, envhash, fix_cmd)
            return 0


def main():
    if len(sys.argv) < 2 or sys.argv[1] in ("-h", "--help"):
        print(__doc__.strip())
        return

    if sys.argv[1] == "--cache":
        conn = init_db()
        show_cache(conn)
        return

    if sys.argv[1] == "--stats":
        conn = init_db()
        show_stats(conn)
        return

    if sys.argv[1] == "--clear":
        conn = init_db()
        conn.execute("DELETE FROM fixes")
        conn.commit()
        print("Cache cleared.")
        return

    args = sys.argv[1:]
    if "-y" in args or "--yes" in args:
        os.environ["FIX_AUTO_YES"] = "1"
        args = [a for a in args if a not in ("-y", "--yes")]
    if "--local" in args or "--ollama" in args:
        os.environ["FIX_FORCE_LOCAL"] = "1"
        args = [a for a in args if a not in ("--local", "--ollama")]
    if "--safe" in args:
        os.environ["FIX_SAFE_MODE"] = "1"
        args = [a for a in args if a != "--safe"]
    sys.exit(run_fix(args))


if __name__ == "__main__":
    main()
